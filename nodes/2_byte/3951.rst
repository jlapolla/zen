=========================================
Fixing defensive programming antipatterns
=========================================

Pretend your name is James, and you're a proponent of defensive programming. You
probably write code like this:

.. code:: python

  # Python code.

  def sqrt(x):

      if x < 0:
          raise Exception('domain error')

      # Fancy square root code here!
      # ...
      return result

During a code review, your coworker, Octavius, points out that you didn't check
if ``x`` was a number. "What if I pass a boolean?" he asks. He has a point.
"Okay, let me update ``sqrt()``" you reply.

.. code:: diff

   # Diff.

   def sqrt(x):

  +    if not (isinstance(x, int) or isinstance(x, float)):
  +        raise Exception('not a number')
  +
       if x < 0:
           raise Exception('domain error')

       # Fancy square root code here!
       # ...
       return result

.. code:: python

  # Python code.

  def sqrt(x):

      if not (isinstance(x, int) or isinstance(x, float)):
          raise Exception('not a number')

      if x < 0:
          raise Exception('domain error')

      # Fancy square root code here!
      # ...
      return result

You're pleased with yourself. Octavius raises his hand again: "James, what if I
pass a list of numbers?" he asks. You think about what should happen if client
code passes a list to ``sqrt()``. "Well, if the client passes a list of numbers,
I suppose I should return a list of their square roots" you reply. You add
another check to ``sqrt()``.

.. code:: python

  # Python code.

  def sqrt(x):

      if isinstance(x, list):
          return map(sqrt, x)

      if not (isinstance(x, int) or isinstance(x, float)):
          raise Exception('not a number')

      if x < 0:
          raise Exception('domain error')

      # Fancy square root code here!
      # ...
      return result

You're pleased with yourself again. But Octavius raises his hand again: "What if
I pass a string?" You consider it for a moment, and reply "Well, I suppose I
could try to convert it to a number."

.. code:: python

  # Python code.

  def sqrt(x):

      if isinstance(x, list):
          return map(sqrt, x)

      if isinstance(x, str):
          return sqrt(float(x))

      if not (isinstance(x, int) or isinstance(x, float)):
          raise Exception('not a number')

      if x < 0:
          raise Exception('domain error')

      # Fancy square root code here!
      # ...
      return result

Finally, Octavius is satisfied. ``sqrt()`` rejects all inputs that are not
numbers, unless the input is a list, in which case it applies ``sqrt()`` to
every member of the list. Or if the input is a string, it converts it to a
number, and applies ``sqrt()``. It seems bullet proof. It even has the added
benefit that it will handle a list of strings!

Separating responsibilities
===========================

Now I'm going to propose that we make ``sqrt()`` even more modular. Let's
decompose it into a suite of related functions. Our goal is to give each
function a single responsibility. That way, our code follows the `single
responsibility principle`_.

.. _`single responsibility principle`: https://en.wikipedia.org/wiki/Single_responsibility_principle

As a first step, we'll separate the argument checks from the "fancy square root"
algorithm.

.. code:: python

  # Python code.

  def checked_sqrt(x):

      if isinstance(x, list):
          return map(checked_sqrt, x)

      if isinstance(x, str):
          return checked_sqrt(float(x))

      if not (isinstance(x, int) or isinstance(x, float)):
          raise Exception('not a number')

      if x < 0:
          raise Exception('domain error')

      return sqrt(x)

  def sqrt(x):

      # Fancy square root code here!
      # ...
      return result

Next, we'll separate the type detection from the action performed on each type.

.. code:: python

  # Python code.

  def checked_sqrt(x):

      if isinstance(x, list):
          return sqrt_list(x)

      if isinstance(x, str):
          return sqrt_str(x)

      if not (isinstance(x, int) or isinstance(x, float)):
          raise Exception('not a number')

      if x < 0:
          raise Exception('domain error')

      return sqrt(x)

  def sqrt_list(x):
      return map(checked_sqrt, x)

  def sqrt_str(x):
      return checked_sqrt(float(x))

  def sqrt(x):

      # Fancy square root code here!
      # ...
      return result

It seems odd that there's a ``sqrt_list()`` and a ``sqrt_str()``, but there's no
``sqrt_int()`` or ``sqrt_float()``. For the sake of symmetry, we'll refactor to
introduce ``sqrt_int()`` and ``sqrt_float()``.

.. code:: python

  # Python code.

  def checked_sqrt(x):

      if isinstance(x, list):
          return sqrt_list(x)

      if isinstance(x, str):
          return sqrt_str(x)

      if isinstance(x, int):
          return sqrt_int(x)

      if isinstance(x, float):
          return sqrt_float(x)

      raise Exception('unhandled type')

  def sqrt_list(x):
      return map(checked_sqrt, x)

  def sqrt_str(x):
      return sqrt_float(float(x))

  def sqrt_int(x):
      if x < 0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt_float(x):
      if x < 0.0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt(x):

      # Fancy square root code here!
      # ...
      return result

Look at that beautiful symmetry. Now the separation of responsibilities is
clear.

- ``checked_sqrt()`` checks the type of ``x``, and dispatches to the associated
  function.
- ``sqrt_list()`` handles ``list`` type arguments.
- ``sqrt_str()`` handles ``str`` type arguments.
- ``sqrt_int()`` handles ``int`` type arguments.
- ``sqrt_float()`` handles ``float`` type arguments.
- ``sqrt()`` does the actual "fancy square root" algorithm.

Octavius strikes back
=====================

In your next code review, Octavius isn't happy. He says, "James, now I can't
pass a string to ``sqrt()``." You reply, "If you want to pass a string, use
``sqrt_str()``."

"But what if I want to pass a variable without worrying about its type?" he
whines. You reply, "Use ``checked_sqrt()`` for that. It will take any type of
argument."

"But what if I want to pass a boolean and have it interpreted as zero or one?"
he insists. A little annoyed, you reply "Octavius, why would you want to take
the square root of zero or one. You already know that the square root of zero is
zero and the square root of one is one. If you really want, I can make a
``sqrt_bool()`` function that returns ``1`` for ``True`` and ``0`` for
``False``. But what's the point?"

"Well, okay" he says. "But, would you please at least document the preconditions
of your functions. I don't want to end up accidentally passing a list to
``sqrt_int()`` or a string to ``sqrt_list()``." You think about this a moment.
"I guess I could document the preconditions of each function. I had thought it
was obvious and easy to remember what type of arguments you can pass to each
function since the function is named after the type of the argument. Do you
really need this documented to use these functions correctly?"

Octavius says, "Well, I guess that's true for most of the functions. And
``checked_sqrt()`` will accept any argument type, so I'm not worried about that
one. But ``sqrt()`` doesn't have the argument type in its name. Can you just
document the preconditions for ``sqrt()`` so I don't call it with the wrong
arguments?"

This sounds reasonable to you. You update your code.

.. code:: python

  # Python code.

  def checked_sqrt(x):

      if isinstance(x, list):
          return sqrt_list(x)

      if isinstance(x, str):
          return sqrt_str(x)

      if isinstance(x, int):
          return sqrt_int(x)

      if isinstance(x, float):
          return sqrt_float(x)

      raise Exception('unhandled type')

  def sqrt_list(x):
      return map(checked_sqrt, x)

  def sqrt_str(x):
      return sqrt_float(float(x))

  def sqrt_int(x):
      if x < 0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt_float(x):
      if x < 0.0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt(x):

      """Apply the "fancy square root" algorithm to 'x'.

      Preconditions:
      - 'x' is a number.
      - 'x' is greater than or equal to zero.
      """

      # Fancy square root code here!
      # ...
      return result

Octavius is reasonably happy with this. "One more request," he adds. "Can you at
least check that ``x`` is not negative in ``sqrt()``?" he asks. You concede.
"Okay, Octavius" you say. You change the code again.

.. code:: python

  # Python code.

  def checked_sqrt(x):

      if isinstance(x, list):
          return sqrt_list(x)

      if isinstance(x, str):
          return sqrt_str(x)

      if isinstance(x, int):
          return sqrt_int(x)

      if isinstance(x, float):
          return sqrt_float(x)

      raise Exception('unhandled type')

  def sqrt_list(x):
      return map(checked_sqrt, x)

  def sqrt_str(x):
      return sqrt_float(float(x))

  def sqrt_int(x):
      if x < 0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt_float(x):
      if x < 0.0:
          raise Exception('domain error')
      return sqrt(x)

  def sqrt(x):

      """Apply the "fancy square root" algorithm to 'x'.

      Preconditions:
      - 'x' is a number.
      - 'x' is greater than or equal to zero.
      """

      if x < 0.0:
          raise Exception('domain error')

      # Fancy square root code here!
      # ...
      return result

Using your code
===============

With ``sqrt()`` and friends out of the way, you start writing functions that use
your new square root library. You start on the ``floopteedoo()`` function.

.. code:: python

  def floopteedoo(x):
      if not (isinstance(x, int)):
          raise Exception('not an int')
      result = []
      while x > 0:
          result.append(checked_sqrt(x))
          x -= 1
      return result

You review your code carefully. Then you realize that by the time you call
``checked_sqrt()``, you have already verified that ``x`` is an integer. You know
that ``checked_sqrt()`` is going to check the type of ``x`` again, you know that
the check is redundant, and you want your code to run just a bit faster. So, you
change it to call ``sqrt_int()`` directly, instead of calling
``checked_sqrt()``.

.. code:: python

  def floopteedoo(x):
      if not (isinstance(x, int)):
          raise Exception('not an int')
      result = []
      while x > 0:
          result.append(sqrt_int(x))
          x -= 1
      return result

Then, you notice something else: because of the condition in the while loop, you
know that ``x`` is non-negative when you call ``sqrt_int()``. You also know that
``sqrt_int()`` is going to check if ``x`` is non-negative, and then pass it to
``sqrt()``. So, why not skip the extra non-negative check, and pass ``x``
directly to ``sqrt()``? You update your code to call ``sqrt()`` directly instead
of calling ``sqrt_int()``.

.. code:: python

  def floopteedoo(x):
      if not (isinstance(x, int)):
          raise Exception('not an int')
      result = []
      while x > 0:
          result.append(sqrt(x))
          x -= 1
      return result

You continue with writing your the other functions you need to implement your
new feature: ``bangarang()``, ``hollybar()``, and ``umbilicate()``. Each of
these functions uses some features from your new square root library.

*Aside: In this case, the performance benefit from calling ``sqrt()`` directly
is negligible because the checks that ``checked_sqrt()`` performs are fast.
However, there are cases where the cost of an extra check is substantial.
Consider a function that takes a directed acyclic graph, ``topo_order(g)``, and
the checked version ``checked_topo_order(g)`` that checks ``g.has_cycles()``
before calling down to ``topo_order(g)``. If ``g`` is a graph without cycles,
performing the cycle check will visit every node and edge in the graph, a very
expensive operation. Therefore, you want to do the cycle check _ONLY ONCE_, and
skip subsequent checks. So, if you already have a graph that you know has no
cycles, you want to call ``topo_order(g)`` directly, instead of calling
``checked_topo_order(g)``. Otherwise your performance will suffer.*

*Aside: In a large application, call stacks can be hundreds or thousands of
function calls deep. If each function checks the type of ``x`` before passing it
to the next function, the performance impact can really add up. Now, apply that
same reasoning to our ``topo_order(g)`` example; you certainly don't want to
call ``g.has_cycles()`` thousands of times.*

Code coverage
=============

**UNDER CONSTRUCTION**
